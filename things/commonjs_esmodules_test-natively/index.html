<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>CommonJS, ES Modules, and Why to Test Natively in One or the Other</title>
		<meta name="description" content="What is the difference between CommonJS and ES Modules, and how does this impact what unit test frameworks you can use?">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Wade Armstrong">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="Wade Armstrong">
		
		<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=VT323|Fira+Code">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
		<style>* { box-sizing: border-box; }
/* Colors */
:root {
  --color-bg: #333;
  --color-text: #333;
  --color-accent: #5CB85C;
  --color-bg-header: #333;
  --color-text-header: #5CB85C;
  --color-bg-nav: transparent;
  --color-text-nav: #5CB85C;
	--color-text-nav-glow: #7ac27a;
  --color-bg-main: #333;
  --color-text-main: #5CB85C;
  --color-bg-footer: #333;
  --color-text-footer: #5CB85C;
}

/* Global */
body {
  margin: 0 auto 0 auto;
	max-width: 100ch;
  font-family: 'VT323', monospace;
  font-size: 1em;
  line-height: 1.5;
  color: var(--color-text);
  background-color: var(--color-bg);
	background: radial-gradient(circle at center,
		#222222 0%,
		#242424 20%,
		#262626 40%,
		#282828 50%,
		#2A2A2A 60%,
		#2C2C2C 68%,
		#2F2F2F 75%,
		#333333 80%,
		#353535 85%,
		#383838 90%,
		#3A3A3A 95%
	);
}

/* Header */
header {
  font-family: 'VT323', monospace;
  color: var(--color-text-header);
  padding: 20px 0px 10px 0px;
	margin: 0px;
	max-height: 11vh;
}

header h1, header h1 a:any-link {
  margin: 0px;
	color: var(--color-text-header);
  font-size: 1.5rem;
  font-weight: 700;
	text-decoration: none;
	text-shadow: 0px 0px 2px var(--color-text-nav-glow)
}

/* Navigation */
nav {
  display: flex;
  justify-content: space-between;
  align-items: left;
	font-family: 'VT323', monospace;
  font-size: 1.5rem;
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
}

nav ul li {
	margin-right: 3ch;
}

nav a {
  color: var(--color-text-nav);
  text-decoration: none;
  font-weight: 700;
	display: inline-block;
	text-shadow: 0px 0px 2px var(--color-text-nav-glow);
}

nav a::first-letter {
	color: var(--color-bg);
	background-color: var(--color-text-nav);
	padding: 0px 1px 0px 1px;
	margin-right: 1px;
	box-shadow: 0px 0px 2px var(--color-text-nav-glow);
}

/* Main */
main {
  /* background-color: var(--color-bg-main); */
  color: var(--color-text-main);
  padding: 0 20px 0 20px;
	max-width: 120ch;
  max-height: 85vh;
	overflow:hidden;
  overflow-y: scroll;
  margin: 0 auto;
	scrollbar-width: none; /* hide scrollbar in most browsers */
  -moz-scrollbar: none; /* hide scrollbar in Firefox */
}

main h2 {
  font-size: 2rem;
  font-weight: 700;
  margin-top: 0;
}

main p {
  margin: 0 0 20px 0;
}

main a {
  color: var(--color-accent);
}

/* Footer */
footer {
  /* background-color: var(--color-bg-footer); */
  color: var(--color-text-footer);
  padding: 12px 0px 1px 5px;
  text-align: center;
	position: fixed;
  bottom: 0;
	width: 100%;
	line-height: 1.2;
	min-height: 2.1rem;
}

main::-webkit-scrollbar {
  width: 0;
}

.visually-hidden {
	display: none;
}

main p, main li {
	font-family: 'Fira Code', sans-serif;
	font-size: 1em;
}

code[class*=language-], pre[class*=language-] {
	white-space: pre-wrap !important;
	/* Yes, !important is a hack, but I'm dependent on 3rd-party css from Prism here */
}</style>
		<script language="Javascript">
			const urls = {
				'r': '/readme/',
				'h': '/',
				't': '/things/'
			};

			document.addEventListener('keypress', function(event) {
				const key = event.key.toLowerCase();
				if (urls.hasOwnProperty(key)) {
					console.log(`Received your keypress, navigating to ${urls[key]}`);
					window.location.href = urls[key];
				}
			});
		</script>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<h1><a href="/" class="home-link">Wade Armstrong</a></h1>
		</header>

		<main id="skip">
			<h1 id="commonjs-es-modules-and-why-to-test-natively-in-one-or-the-other" tabindex="-1">CommonJS, ES Modules, and Why to Test Natively in One or The Other <a class="header-anchor" href="#commonjs-es-modules-and-why-to-test-natively-in-one-or-the-other">#</a></h1>
<p>In Javascript, there are two different ways that a given file can export functions, objects, values, and other components, for reuse in a second file or files — CommonJS ('CJS') and ES Modules ('ESM'). These two methods of export are actually surprisingly different, because they were designed for use in completely separate circumstances.</p>
<h2 id="where-you-ll-see-the-difference" tabindex="-1">Where You'll See The Difference <a class="header-anchor" href="#where-you-ll-see-the-difference">#</a></h2>
<p>If you've worked in Javascript for a while, you've probably become used to the <a href="https://nodejs.org/docs/latest-v20.x/api/modules.html#requireid"><code>require()</code></a> syntax for including the contents of other files, and the <a href="https://nodejs.org/docs/latest-v20.x/api/modules.html#moduleexports"><code>module.exports</code></a> syntax for exporting features from a file:</p>
<pre class="language-javascript" tabindex="0"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> importedModule <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'/path/to/module.js'</span><span class="token punctuation">)</span><br><br><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">importedModule</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><br>	value<br><span class="token punctuation">}</span> </code></pre>
<p>That's a tip-off that you're using CommonJS; ESM uses <a href="https://tc39.es/ecma262/#sec-imports"><code>import</code></a> and <a href="https://tc39.es/ecma262/#sec-exports"><code>export</code></a> for the same jobs:</p>
<pre class="language-javascript" tabindex="0"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> importedModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'/path/to/module.js'</span><br><br><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">importedModule</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">export</span> <span class="token keyword">default</span> value<span class="token punctuation">;</span></code></pre>
<p>For most developers, this will be the only time they see a difference between the two approaches. Which syntax you use is probably going to be defined by the frameworks you're using:</p>
<ul>
<li>Node natively supports CJS, but has supported ESM since v.12</li>
<li>React supports both, but <a href="https://create-react-app.dev">create-react-app</a> uses ESM (which one you choose will primarily be defined by your bundler)</li>
<li>Angular supports both, but strongly prefers ESM</li>
<li>Vue switched to ESM in v.13</li>
</ul>
<p>While technically you can mix CJS and ESM in a single project,<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> that's a good way to cause build chain problems. You can't practically mix the two syntaxes in a single file<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p>
<h2 id="what-is-the-difference-under-the-hood" tabindex="-1">What Is The Difference Under The Hood <a class="header-anchor" href="#what-is-the-difference-under-the-hood">#</a></h2>
<p>But it's not just build chains that have trouble with the two different export formats — there are actually significant technical differences in the way that ESM and CJS are implemented.</p>
<h3 id="why-commonjs-is-here" tabindex="-1">Why CommonJS is Here <a class="header-anchor" href="#why-commonjs-is-here">#</a></h3>
<p>First, a little history. When Node first came around, there was no standardized way to include components from different files. They chose CommonJS, one of the major proposals at the time, not least because it was straightforward to use on servers<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</p>
<p>One thing that made it so straightforward on servers was that it loads all included modules <em>synchronously</em> — that is, it kind of assumes that the modules will just 'be there' when it hits the <code>require()</code> line in the code. This is true on servers, so that's a great choice for Node.</p>
<h3 id="why-es-modules-are-here" tabindex="-1">Why ES Modules are Here <a class="header-anchor" href="#why-es-modules-are-here">#</a></h3>
<p>Of course, on the Web, files are not at all 'just there' — they take a while to load from wherever in the world they are hosted. CJS's synchronous approach to loading would result in the browser appearing to stall as each dependency was loaded, in order; an asynchronous approach, matching the way assets like CSS and images are loaded in the browser, was clearly required.</p>
<p>That's where ES Modules come in. They implement something called 'top level await', which is basically just a way of saying &quot;You know how <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a> works? Every ES Module is by default wrapped in that.&quot;</p>
<h3 id="but-it-s-not-just-synchronous-vs-asynchronous" tabindex="-1">But it's Not Just Synchronous vs. Asynchronous <a class="header-anchor" href="#but-it-s-not-just-synchronous-vs-asynchronous">#</a></h3>
<p>Understanding synchronous vs. asynchronous is a good first step, but the real difference under the hood — and the reason why you want to test natively in whatever exports approach your build chain uses — comes down to the consequences of being synchronous or asynchronous.</p>
<p>Imagine your Javascript interpreter parsing a single file. It hits a line like:</p>
<pre class="language-javascript" tabindex="0"><code class="language-javascript"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">47</span><span class="token punctuation">;</span></code></pre>
<p>The interpreter can then:</p>
<ol>
<li>Allocate memory for the value of <code>foo</code> to inhabit</li>
<li>Populate that memory with <code>47</code></li>
<li>Move on and be done with it</li>
</ol>
<p>Nice and simple, right? But what if the value <code>47</code> isn't there yet?</p>
<pre class="language-javascript" tabindex="0"><code class="language-javascript"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchFortySeven</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>If you've used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promises</code></a> before, you'll know that the interpreter works more like:</p>
<ol>
<li>Allocate memory for the value of <code>foo</code> to inhabit</li>
<li>Populate that memory with a Promise</li>
<li>Move on to the next thing</li>
<li>Check periodically in the Event Loop for the Promise to be fulfilled</li>
<li>...</li>
<li>...</li>
<li>Now finally populate the memory with <code>47</code></li>
</ol>
<p>This pretty much describes the under-the-hood difference between CJS and ESM.</p>
<ul>
<li>CJS immediately and synchronously processes all exports and sets their value in memory at that time</li>
<li>ESM asynchronously processes all exports and sets their value in memory when all required processes (loading, calculating, etc.) have been completed</li>
</ul>
<p>As a consequence of this:</p>
<ul>
<li>CJS exports <em>can never</em> be recalculated during a given execution; they are what they are at the initial export time. So, if you have a module that exports a default; waits for a Promise to resolve; then exports the new value, the CJS import will only ever get the default value.</li>
<li>ESM exports <em>can</em> be recalculated during a given execution. In the previous example, the exported value would change during the execution, and you would be able to access the new value.</li>
</ul>
<h2 id="an-esm-testing-toolchain" tabindex="-1">An ESM Testing Toolchain <a class="header-anchor" href="#an-esm-testing-toolchain">#</a></h2>
<p>Obviously this means that you need to be careful in testing — you want to write tests that check the <em>actual</em> value the code will produce in production, and it's a problem if the tests assume the value will never change and it does (or vice versa). So stick to a testing toolchain that natively uses whatever module format your build chain exports.</p>
<p>Facebook's excellent Jest testing framework <a href="https://jestjs.io/docs/ecmascript-modules">does not yet support ES Modules well</a>, so, while it's a great choice for CJS build chains, you should avoid it for ESM.</p>
<p>For ES Modules, I like the Mocha framework, which has <a href="https://mochajs.org/#nodejs-native-esm-support">supported ESM since mid-2020</a>. It doesn't offer all of the great React-specific features you get for free in Jest, but it's a solid, flexible, and fast framework.</p>
<p>Now you know the difference between ES Modules and CommonJS. Go out, and reuse your code!</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>And you may have, depending on the npm modules you use. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>You're basically using CJS and <code>require</code>ing external files to give you the ESM interfaces, and your build chain will need to reflect that you're using both, so you'd really better be determined to mix it up! <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>The syntax for CJS is also, to my eyes at least, <a href="https://requirejs.org/docs/whyamd.html#amd">cleaner than that of an early competitor, AMD</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

		</main>

		<footer>
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/readme/">README</a></li>
					<li class="nav-item"><a href="/things/">Things I&#39;ve Learned</a></li>
				</ul>
			</nav>
		</footer>

		<!-- Current page: /things/commonjs_esmodules_test-natively/ -->
	</body>
</html>
