<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="en">
	<title>Wade Armstrong</title>
	<subtitle>Engineering Leader With Proven Record of Building High-Performing, Quality-Oriented Teams.</subtitle>
	<link href="https://wadearmstrong.com/feed/feed.xml" rel="self"/>
	<link href="https://wadearmstrong.com/"/>
	<updated>2020-04-01T00:00:00Z</updated>
	<id>https://wadearmstrong.com/</id>
	<author>
		<name>Wade Armstrong</name>
		<email>wade@wadearmstrong.com</email>
	</author>
	
	<entry>
		<title>CommonJS, ES Modules, and Why to Test Natively in One or the Other</title>
		<link href="https://wadearmstrong.com/commonjs_esmodules_test-natively/"/>
		<updated>2020-04-01T00:00:00Z</updated>
		<id>https://wadearmstrong.com/commonjs_esmodules_test-natively/</id>
		<content type="html">&lt;h1 id=&quot;commonjs-es-modules-and-why-to-test-natively-in-one-or-the-other&quot; tabindex=&quot;-1&quot;&gt;CommonJS, ES Modules, and Why to Test Natively in One or The Other &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;In Javascript, there are two different ways that a given file can export functions, objects, values, and other components, for reuse in a second file or files — CommonJS (&#39;CJS&#39;) and ES Modules (&#39;ESM&#39;). These two methods of export are actually surprisingly different, because they were designed for use in completely separate circumstances. Because they&#39;re so different, it&#39;s important to test them using a different toolchain.&lt;/p&gt;
&lt;h2 id=&quot;where-you-ll-see-the-difference&quot; tabindex=&quot;-1&quot;&gt;Where You&#39;ll See The Difference &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If you&#39;ve worked in Javascript for a while, you&#39;ve probably become used to the &lt;a href=&quot;https://nodejs.org/docs/latest-v20.x/api/modules.html#requireid&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; syntax for including the contents of other files, and the &lt;a href=&quot;https://nodejs.org/docs/latest-v20.x/api/modules.html#moduleexports&quot;&gt;&lt;code&gt;module.exports&lt;/code&gt;&lt;/a&gt; syntax for exporting features from a file:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; importedModule &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;/path/to/module.js&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;importedModule&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;exports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;	value&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&#39;s a tip-off that you&#39;re using CommonJS; ESM uses &lt;a href=&quot;https://tc39.es/ecma262/#sec-imports&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://tc39.es/ecma262/#sec-exports&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; for the same jobs:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; importedModule &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;/path/to/module.js&#39;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;importedModule&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For most developers, this will be the only time they see a difference between the two approaches. Which syntax you use is probably going to be defined by the frameworks you&#39;re using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node natively supports CJS, but has supported ESM since v.12&lt;/li&gt;
&lt;li&gt;React supports both, but &lt;a href=&quot;https://create-react-app.dev&quot;&gt;create-react-app&lt;/a&gt; uses ESM (which one you choose will primarily be defined by your bundler)&lt;/li&gt;
&lt;li&gt;Angular supports both, but strongly prefers ESM&lt;/li&gt;
&lt;li&gt;Vue switched to ESM in v.13&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While technically you can mix CJS and ESM in a single project&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;, that&#39;s a good way to cause build chain problems. You can&#39;t practically mix the two syntaxes in a single file&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&quot;what-is-the-difference-under-the-hood&quot; tabindex=&quot;-1&quot;&gt;What Is The Difference Under The Hood &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;But it&#39;s not just build chains that have trouble with the two different export formats — there are actually significant technical differences in the way that ESM and CJS are implemented.&lt;/p&gt;
&lt;h3 id=&quot;why-commonjs-is-here&quot; tabindex=&quot;-1&quot;&gt;Why CommonJS is Here &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;First, a little history. When Node first came around, there was no standardized way to include components from different javascript files. They chose CommonJS, one of the major proposals for module exporting and loading at the time, not least because it was straightforward to use on servers&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; id=&quot;fnref3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;One thing that made it so straightforward on servers was that it loads all included modules &lt;em&gt;synchronously&lt;/em&gt; — that is, it kind of assumes that the file containing the modules will just &#39;be there&#39; when it hits the &lt;code&gt;require()&lt;/code&gt; line in the code. This is true on servers, so that&#39;s a great choice for Node.&lt;/p&gt;
&lt;h3 id=&quot;why-es-modules-are-here&quot; tabindex=&quot;-1&quot;&gt;Why ES Modules are Here &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Of course, on the Web, files are not at all &#39;just there&#39; — they take a while to load from wherever in the world they are hosted. CJS&#39;s synchronous approach to loading would result in the browser appearing to stall as each dependency was loaded, in order; an asynchronous approach, matching the way assets like CSS and images are loaded in the browser, was clearly required.&lt;/p&gt;
&lt;p&gt;That&#39;s where ES Modules come in. They implement something called &#39;top level await&#39;, which is basically just a way of saying &amp;quot;You know how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; works? Every ES Module is by default wrapped in that.&amp;quot;&lt;/p&gt;
&lt;h3 id=&quot;but-it-s-not-just-synchronous-vs-asynchronous&quot; tabindex=&quot;-1&quot;&gt;But it&#39;s Not Just Synchronous vs. Asynchronous &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Understanding synchronous vs. asynchronous is a good first step, but the real difference under the hood — and the reason why you want to test natively in whatever exports approach your build chain uses — comes down to the consequences of being synchronous or asynchronous.&lt;/p&gt;
&lt;p&gt;Imagine your Javascript interpreter parsing a single file. It hits a line like:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;47&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interpreter can then:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Allocate memory for the value of &lt;code&gt;foo&lt;/code&gt; to inhabit&lt;/li&gt;
&lt;li&gt;Populate that memory with &lt;code&gt;47&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Move on and be done with it&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nice and simple, right? But what if the value &lt;code&gt;47&lt;/code&gt; isn&#39;t there yet?&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetchFortySeven&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you&#39;ve used &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promises&lt;/code&gt;&lt;/a&gt; before, you&#39;ll know that the interpreter works more like:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Allocate memory for the value of &lt;code&gt;foo&lt;/code&gt; to inhabit&lt;/li&gt;
&lt;li&gt;Populate that memory with a Promise&lt;/li&gt;
&lt;li&gt;Move on to the next thing&lt;/li&gt;
&lt;li&gt;Check periodically in the Event Loop for the Promise to be fulfilled&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;Now finally populate the memory with &lt;code&gt;47&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This pretty much describes the under-the-hood difference between CJS and ESM.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CJS immediately and synchronously processes all exports and sets their value in memory at that time&lt;/li&gt;
&lt;li&gt;ESM asynchronously processes all exports and sets their value in memory when all required processes (loading, calculating, etc.) have been completed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a consequence of this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CJS exports &lt;em&gt;can never&lt;/em&gt; be recalculated during a given execution; they are what they are at the initial export time. So, if you have a module that exports a default; waits for a Promise to resolve; then exports the new value, the CJS import will only ever get the default value&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; id=&quot;fnref4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;ESM exports &lt;em&gt;can&lt;/em&gt; be recalculated during a given execution. In the previous example, the exported value would change during the execution, and you would be able to access the new value.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;an-esm-testing-toolchain&quot; tabindex=&quot;-1&quot;&gt;An ESM Testing Toolchain &lt;a class=&quot;header-anchor&quot; href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Obviously this means that you need to be careful in testing — you want to write tests that check the &lt;em&gt;actual&lt;/em&gt; value the code will produce in production, and it&#39;s a problem if the tests assume the value will never change and it does (or vice versa). So stick to a testing toolchain that natively uses whatever module format your build chain exports.&lt;/p&gt;
&lt;p&gt;Facebook&#39;s excellent Jest testing framework &lt;a href=&quot;https://jestjs.io/docs/ecmascript-modules&quot;&gt;does not yet support ES Modules well&lt;/a&gt;, so, while it&#39;s a great choice for CJS build chains, you should avoid it for ESM.&lt;/p&gt;
&lt;p&gt;For ES Modules, I like the Mocha framework, which has &lt;a href=&quot;https://mochajs.org/#nodejs-native-esm-support&quot;&gt;supported ESM since mid-2020&lt;/a&gt;. It doesn&#39;t offer all of the great React-specific features you get for free in Jest, but it&#39;s a solid, flexible, and fast framework.&lt;/p&gt;
&lt;p&gt;Now you know the difference between ES Modules and CommonJS. Go out, and reuse your code!&lt;/p&gt;
&lt;hr class=&quot;footnotes-sep&quot;&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;And you may have, depending on the npm modules you use. &lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;You&#39;re basically using CJS and &lt;code&gt;require&lt;/code&gt;ing external files to give you the ESM interfaces, and your build chain will need to reflect that you&#39;re using both, so you&#39;d really better be determined to mix it up! &lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn3&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;The syntax for CJS is also, to my eyes at least, &lt;a href=&quot;https://requirejs.org/docs/whyamd.html#amd&quot;&gt;cleaner than that of an early competitor, AMD&lt;/a&gt; &lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn4&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;In practice, this is easy to get around: just export a Promise &lt;a href=&quot;https://wadearmstrong.com/commonjs_esmodules_test-natively/&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
	</entry>
</feed>
